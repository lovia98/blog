<!DOCTYPE HTML>
<!--
Prologue by HTML5 UP
html5up.net | @ajlkn
Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
Jekyll integration by Chris Bobbe | chrisbobbe.github.io
-->
<html><head><!-- Robots -->
  <meta name="robots" content="index, follow" /><link rel="canonical" href="http://localhost:4000/studynote/parrelStream.html" /><!-- Title, description, author --><title>병렬 스트림 | Juhee&#39;s Blog - 배우는 개발자</title>
  <meta name="description" content="항상 겸손하게!" />
  <meta name="author" content="Juhee" />

  <!-- Open Graph -->
  <meta property="og:title" content="병렬 스트림 | Juhee&#39;s Blog - 배우는 개발자" />
  <meta property="og:type" content="website" />
  <meta property="og:image" content="http://localhost:4000/studynote/assets/images/08.jpg" />
  <meta property="og:url" content="http://localhost:4000/studynote/parrelStream.html" />
  <meta property="og:site_name" content="Juhee&#39;s Blog" />
  <meta property="og:description" content="항상 겸손하게!" />

  <!-- Styles -->
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!--[if lte IE 8]><script src="/studynote/assets/js/ie/html5shiv.js" defer></script><![endif]-->
  <link rel="stylesheet" href="/studynote/assets/css/main.css" />
  <link rel="stylesheet" href="/studynote/assets/css/mine.css" />
  <!--[if lte IE 8]><link rel="stylesheet" href="/studynote/assets/css/ie8.css" /><![endif]-->
  <!--[if lte IE 9]><link rel="stylesheet" href="/studynote/assets/css/ie9.css" /><![endif]-->

  <!-- Scripts -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js" defer></script>
  <script src="/studynote/assets/js/jquery.scrolly.min.js" defer></script>
  <script src="/studynote/assets/js/jquery.scrollzer.min.js" defer></script>
  <script src="/studynote/assets/js/skel.min.js" defer></script>
  <script src="/studynote/assets/js/util.js" defer></script>
  <!--[if lte IE 8]><script src="/studynote/assets/js/ie/respond.min.js" defer></script><![endif]-->
  <script src="/studynote/assets/js/main.js" defer></script>

</head>
<body><!-- Header -->
<div id="header">
  <div class="top"><!-- Logo -->
<div id="logo">
  <a href="http://localhost:4000/studynote/" id="home-link">
    <span class="image avatar48"><img src="/studynote/assets/images/08.jpg" alt="Avatar of Juhee" /></span>
    <h1 id="title">Juhee's Blog</h1>
    <p>배우는 개발자</p>
  </a>
</div><!-- Nav -->
<nav id="nav">
  <ul><li><a href="http://localhost:4000/studynote/" id="home-link">
            <span class="icon fa-home">Home</span>
          </a></li><li><a href="http://localhost:4000/studynote/spring.html" id="spring-link">
            <span class="icon fa-leaf">Spring</span>
          </a></li><li><a href="http://localhost:4000/studynote/java.html" id="java-link">
            <span class="icon fa-coffee">Java</span>
          </a></li><li><a href="http://localhost:4000/studynote/kotlin.html" id="kotlin-link">
            <span class="icon fa-desktop">Kotlin</span>
          </a></li><li><a href="http://localhost:4000/studynote/etc.html" id="etc-link">
            <span class="icon fa-leaf">etc</span>
          </a></li><li><a href="http://localhost:4000/studynote/patternStudy.html" id="design-pattern-link">
            <span class="icon fa-building">Design Pattern</span>
          </a></li></ul>
</nav></div>
  <div class="bottom"><!-- Social Icons -->
<ul class="icons"><li><a href="mailto:lovia98@daum.net" class="icon fa-envelope"><span class="label">Email</span></a></li></ul>
</div>
</div>
<!-- Main -->
<div id="main">
	<!-- Post -->
	<article class="shade-two font15 darkGray myFontFamily">
	  <div class="container">
			<header>
				<h2>병렬 스트림</h2>
				<p>한주희, 17 May 2018</p>
			</header><p>컬렉션에 paralleStream을 호출하면 <bold>병렬 스트림</bold>이 생성된다. 병렬 스트림이란 각각의 스레드에서
처리할 수 있도록 스트림 요소를 여러 청크로 분할한 스트림이다. 따라서 병렬 스트림을 이용하면 모든 멀티코어 프로세서가
각각의 청크를 처리하도록 할당할 수 있다.</p>

<pre><code class="language-JAVA">//일반 스트림 처리
public long sequentialSum(long n) {
    return Stream.iterate(1L, i -&gt; i+1)
            .limit(n)
            .reduce(0L, Long::sum);
}

//병렬 처리
public long parallelSum(long n) {
    return Stream.iterate(1L, i -&gt; i+1)
            .limit(n)
            .parallel() //스트림을 병렬 스트림으로 변환
            .reduce(0L, Long::sum);
}
</code></pre>
<hr />
<h3 id="스트림-성능-측정">스트림 성능 측정</h3>
<p><br />병렬화를 이용하면 순차나 반복 형식에 비해 성능이 좋아질 것이라 추축되지만, 실제로는 그렇지 않다.
<br />아래와 같이 1부터 n까지 합을 구하는 함수를 만들었다.</p>
<pre><code class="language-JAVA">    //전통적인 처리 : loop
    public static long iterativeSum(long n) {
        long result = 0;
        for(long i = 1L; i&lt;=n; i++) {
            result += i;
        }
        return result;
    }

    //스트림 처리
    public static long sequentialSum(long n) {
        return Stream.iterate(1L, i -&gt; i+1)
                .limit(n)
                .reduce(0L, Long::sum);
    }

    //병렬 처리
    public static long parallelSum(long n) {
        return Stream.iterate(1L, i -&gt; i+1)
                .limit(n)
                .parallel() //스트림을 병렬 스트림으로 변환
                .reduce(0L, Long::sum);
    }
</code></pre>
<p>그리고 아래는 각 함수의 처리 속도를 측정하는 함수이다.</p>
<pre><code class="language-JAVA">  //성능 측정
  public long mesaure(Function&lt;Long, Long&gt; adder, long n) {
      long fastest = Long.MAX_VALUE;

      for(int i = 0; i&lt;10; i++) {
          long start = System.nanoTime();
          long sum = adder.apply(n);
          long duration = (System.nanoTime()-start) / 1_000_000;
         // System.out.println("Result: "+sum);
          if(duration &lt; fastest) fastest = duration;
      }

      return fastest;
  }

  @Test
  public void test() {
      System.out.println(mesaure(ParallTest::iterativeSum, 10_000_000)+" msecs");
      System.out.println(mesaure(ParallTest::sequentialSum, 10_000_000)+" msecs");
      System.out.println(mesaure(ParallTest::parallelSum, 10_000_000)+" msecs");
  }
</code></pre>
<p>실행해 본 결과는 다음과 같다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3 msecs //loop
100 msecs //스트림
78 msecs  //병렬 스트림
</code></pre></div></div>
<p>기대한 바와는 다르게 for 루프가 가장 빠르다. for 루프는 기본값을 박싱하거나 언박싱할 필요가 없으므로 수행속도가 빠르다.
 <br />책(자바인액션)의 결과와는 다르게 나의 경우 병렬 스트림 처리가 일반 스트림 처리 보다 더 수행속도가 빠른 것으로 나왔다.
 <br />하지만 이런 경우 병렬 스트림처리가 느리다고 소개되어 있으니 그 이유를 정리 하고 가겠다.</p>
<ul>
  <li>Stream.iterate가 박싱된 객체를 생성하므로 이를 다시 언박싱하는 과정이 필요했다.</li>
  <li>Stream.iterate는 병렬로 실행될 수 있도록 독립적인 청크로 분할하기가 어렵다.</li>
</ul>

<p>두번째 이유를 자세히 설명하자면,</p>
<ul>
  <li>스트림 연산은 최종 연산이 진행되기 전까지는 연산을 미루는 Lazy 연산을 한다.</li>
  <li>따라서 위 병렬처리 함수(parallelSum)로직에서 iterate함수가 stream내에서 이루어 짐으로 .reduce가 실행되기 전까지 전체 숫자 리스트가 준비 되지 않는다.</li>
  <li>전체 숫자 리스트가 준비되지 않았으므로 스트림을 병렬로 처리할 수 있도록 청크로 분할할 수 없다.</li>
</ul>

<p>스트림이 병렬로 처리되도록 지시했고 각각의 합계가 다른 스레드에서 수행되었지만 결국 순차처리 방식과 크게 다른 점이 없으므로
   스레드를 할당하는 오버헤드만 증가하게 된다.</p>

<p>다음은 이러한 문제점을 개선한 함수이다.</p>
<pre><code class="language-JAVA">//개선된 처리
public static long paralleRangeSum(long n) {
    return LongStream.rangeClosed(1, n)
            .parallel()
            .reduce(0L, Long::sum);
}
</code></pre>
<p>처리 결과는 다음과 같이 가장 빨랐다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Test
public void test1() {
    System.out.println(mesaure(ParallTest::paralleRangeSum, 10_000_000)+" msecs");
}

1 msecs
</code></pre></div></div>
<p>빨라진 이유는 다음과 같은 이유에서다.</p>
<ul>
  <li>long타입에 특화된 LongStream을 사용함으로서 박싱과 언박싱 오버헤드가 사라진다.</li>
  <li>LongStream.rangeClosed는 쉽게 청크로 분할할 수 있도록 숫자 범위가 정해진다.</li>
</ul>

<h3 id="결론">결론</h3>
<p><br />병렬화를 이용하려면 스트림을 재귀적으로 분할해야 하고, 각 서브스트림의 연산결과를 하나의 값으로 합쳐야 한다.
<br />멀티코어간의 데이터 이동은 우리 생각보다 비싸서 데이터 전송 시간보다 훨씬 오래 걸리는 작업만 병렬화 하는 것이 좋다.</p>

<ul>
  <li>확신이 서지 않는다면 직접 측정하라.</li>
  <li>박싱 : 자동 박싱과 언박싱은 성능을 크게 저하시킬 수 있는 요소다. 되도록이면 기본형 특화 스트림을 사용하는 것이 좋다.</li>
  <li>순차 스트림보다 병렬 스트림에서 성능이 떨어지는 연산이 있다. - 특히 limit이나 findFirst처럼 요소의 순서에 의존하는
<br />연산을 병렬 스트림에서 수행하려면 비싼 비용을 치러야 한다. 예를 들어 findAny는 요소의 순서와 상관 없이 연산하므로
<br />findFisrt보다 성능이 좋다.</li>
  <li>스트림에서 수행하는 전체 파이프라인 연산비용을 고려해라. 하나의 요소를 처리하는데 드는 비용이 커지면 커질 수록 병렬 스트림
으로 성능을 개선할 수 있는 가능성이 있음을 의미한다.</li>
  <li>소량의 데이터에서는 병렬 스트림이 도움 되지 않는다. 소량의 데이터를 처리하는 상황에서는 병렬화 과정에서 생기는 부가 비용을
상쇄할 수 있을 만큼의 이득을 얻지 못하기 때문이다.</li>
  <li>스트림을 구성하는 자료구조가 적절한지 확인하라.
<br />예를 들면 ArrayList가 LinkedList보다 분할하기 낫고, range팩토리 메서드로 만든 기본형 스트림을 쓰는 것이 좋다.</li>
  <li>스트림의 중간연산이 스트림의 특성을 어떻게 바꾸는지도 생각해봐야 한다. filter연산이 있는 경우 스트림의 길이를 예측 할
수 없으므로 효과적으로 스트림을 병렬 처리 할 수 있을지 알 수 없게 된다.</li>
  <li>최종 연산의 병합과정(예를 들면 Collector의 combiner 메서드) 비용을 살펴 보라. 병합 과정의 비용이 비싸다면
<br />병렬 스트림으로 얻은 성능의 이익이 서브스트림의 부분결과를 합치는 과정에서 상쇄될 수 있다.</li>
</ul>

<div id="disqus_thread"></div>
<script>
  /**
  *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
  *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
  /*
  var disqus_config = function () {
  this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
  this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
  };
  */
  (function() { // DON'T EDIT BELOW THIS LINE
  var d = document, s = d.createElement('script');
  s.src = 'https://juhee-studynote.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
  })();
</script>

<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</div>
	</article>
</div>
<!-- Footer -->
<div id="footer">

  <!-- Copyright -->
  <ul class="copyright">
    
      <li>&copy;Juhee's Blog. All rights reserved.</li>
    
    <li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
    <li>Jekyll integration: <a href="https://chrisbobbe.github.io/">Chris Bobbe</a></li>
  </ul>

</div>
<script id="dsq-count-scr" src="//juhee-studynote.disqus.com/count.js" async></script>
</body>
</html>